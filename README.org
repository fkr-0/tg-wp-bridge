#+TITLE: tg-wp-bridge
#+SUBTITLE: Telegram channel → WordPress category bridge

* Tp->Wp

Do the telegram & wordpress boogie. *in style*.

** Concept
- Required
  - publicly reachable (sub) url
  - credentials for tg bot (token)
  - credentials for running wp instance (user, app password)

1. We configure an existing telegram bot (through ~api.telegram.org~ + bot token), to call
   our publicly reachable endpoint when bot receives message. This ~webhook~ receives
   the message as content of a ~POST~ request. We use that requests body to..
2. Parse / extract relevant data from the telegram message:
   - tags
   - title
   - media content
3. We send an authenticated ~POST~ request against ~WORDPRESS_URL/wp-json/wp/v2/posts"~. In
   the body we provide a suitable representation of the *parsed* telegram message, leading
   to the creation of a new blog post published at ~WORDPRESS_URL~ according to the
   properties we provide with our request.

#+begin_src ascii
[Telegram Channel]
        |
        | (forwarded via bot)
        v
[Telegram Bot Webhook (our service, in Docker)]
        |
        | 1. Parse message (text + media URLs)
        | 2. Optionally download media
        | 3. POST to WordPress REST API
        v
[WordPress REST API]
        |
        v
[New Post in Category X]
#+end_src


=tg-wp-bridge= is a small FastAPI service that mirrors Telegram channel posts
onto a WordPress blog via the WordPress REST API.

Flow:

#+BEGIN_SRC text
Telegram Channel
   |
   v
Telegram Bot (webhook)  --->  tg-wp-bridge (FastAPI, Docker)
                                   |
                                   v
                             WordPress REST API
                               (wp-json/wp/v2/posts)
#+END_SRC

Each channel message becomes a WordPress post in a configured category:
- Text → post title & content
- Photo (optional) → uploaded as media, set as =featured_media=

No WordPress plugin required; the built-in REST API + Application Passwords
are sufficient.

* Project Layout

#+BEGIN_SRC text
.
├── pyproject.toml
├── README.org
├── tg_wp_bridge
│   ├── __init__.py
│   ├── app.py
│   ├── config.py
│   ├── message_parser.py
│   ├── schemas.py
│   ├── telegram_api.py
│   └── wordpress_api.py
└── tests
    ├── docker-compose.wordpress.yml
    ├── test_message_parser.py
    └── test_config.py
#+END_SRC

* Configuration

Configuration is handled via =pydantic-settings= in =tg_wp_bridge/config.py=.

Environment variables (can be provided via =.env= or container env):

#+BEGIN_SRC text
TELEGRAM_BOT_TOKEN       # Bot token from BotFather
TELEGRAM_WEBHOOK_SECRET  # Path secret for /webhook/{secret}
PUBLIC_BASE_URL          # e.g. https://bridge.example.com

WP_BASE_URL              # e.g. https://blog.example.com
WP_USERNAME              # WordPress user with Application Password
WP_APP_PASSWORD          # Application password
WP_CATEGORY_ID           # Numeric category ID
WP_PUBLISH_STATUS        # publish | draft | pending (default: publish)
#+END_SRC

The service automatically reads:

- Environment variables.
- A =.env= file in the current working directory.

An example file is provided as =env.example=.

** Using =.env=

#+BEGIN_SRC bash
cp env.example .env
# edit .env with your values
$EDITOR .env
#+END_SRC

Relevant keys:

#+BEGIN_SRC text
TELEGRAM_BOT_TOKEN       # Bot token from BotFather
TELEGRAM_WEBHOOK_SECRET  # Path secret for /webhook/{secret}
PUBLIC_BASE_URL          # e.g. https://bridge.example.com

WP_BASE_URL              # e.g. http://localhost:8080
WP_USERNAME              # WordPress user with Application Password
WP_APP_PASSWORD          # Application password
WP_CATEGORY_ID           # Numeric category ID
WP_PUBLISH_STATUS        # publish | draft | pending (default: publish)

REQUIRED_HASHTAG         # Optional: e.g. "#blog"
                         # If set, only messages containing this hashtag
                         # will be mirrored to WordPress.
CHAT_TYPE_ALLOWLIST      # Optional: e.g. "channel,supergroup" (default: channel)
HASHTAG_ALLOWLIST        # Optional comma-separated whitelist (any match)
HASHTAG_BLOCKLIST        # Optional comma-separated blacklist
#+END_SRC

Internally, =tg_wp_bridge.config.Settings= is configured with:

#+BEGIN_SRC python
model_config = SettingsConfigDict(
  env_file=".env",
  env_file_encoding="utf-8",
  extra="ignore",
)
#+END_SRC

so you can rely on =.env= for local dev and fall back to environment
variables in production.

* Parsing & Mirroring Logic (high level)

Key parsing helpers in =tg_wp_bridge/message_parser.py=:

- =extract_message_entity= :: Pick =channel_post= over =message= where present.
- =extract_message_text=   :: Prefer =text=, then =caption=.
- =extract_hashtags=       :: Extract hashtags (=#tag=) from text.
- =build_title_from_text=  :: Take first non-empty line, strip leading
     hashtags, truncate to 60 chars.
- =text_to_html=           :: Convert plain text to very simple HTML:
     paragraphs on double-newlines, =<br>= within paragraphs.

The main handler (=handle_telegram_update= in =tg_wp_bridge/app.py=):

1. Checks the Telegram chat type against =CHAT_TYPE_ALLOWLIST= (defaults to
   =channel=).
2. Extracts text/caption; if there is no text it will proceed as long as
   supported media (photo/video/animation/document) is present.
3. Applies hashtag rules: the legacy =REQUIRED_HASHTAG=, plus optional
   whitelist (=HASHTAG_ALLOWLIST=) and blacklist (=HASHTAG_BLOCKLIST=).
4. Builds a title via =build_title_from_text= (falls back to "(no title)").
5. Renders basic HTML via =text_to_html=.
6. Collects supported media, downloads each file and uploads it to WordPress
   (images, videos, animations, and general documents).
7. Embeds the returned WordPress =source_url= in the post body so readers see
   the original, uncropped asset (images become <img>, videos become
   <video>, and other files are linked directly).
8. Creates a WordPress post; the first uploaded media ID becomes
   =featured_media= when available.


* Running Locally (FastAPI only)

#+BEGIN_SRC bash
python -m venv .venv
source .venv/bin/activate

pip install -e ".[dev]"   # from pyproject, if you want dev deps
# or: pip install fastapi uvicorn[standard] httpx pydantic-settings pytest pytest-asyncio

export TELEGRAM_BOT_TOKEN="123:abc"
export TELEGRAM_WEBHOOK_SECRET="supersecret"
export PUBLIC_BASE_URL="https://bridge.example.com"
export WP_BASE_URL="http://localhost:8080"
export WP_USERNAME="wpuser"
export WP_APP_PASSWORD="app-password"
export WP_CATEGORY_ID="1"

uvicorn tg_wp_bridge.app:app --host 0.0.0.0 --port 8000

#+END_SRC

* Example WordPress Test Stack (docker-compose.wordpress.yml)

Under =tests/docker-compose.wordpress.yml= there is an example stack that runs:
- WordPress
- MariaDB
- (Optionally) the bridge (comment/uncomment)

This is meant for local testing, not production.

Usage:

#+BEGIN_SRC bash
cd tests
docker compose -f docker-compose.wordpress.yml up -d

# WordPress will be on http://localhost:8080
# First-time setup: create admin user + enable Application Passwords
#+END_SRC

* CLI Management Commands

The bridge includes a CLI tool for management operations without requiring the webserver to be running. This is especially useful for initial setup and troubleshooting.

** Installation

The CLI is available after installing the package:

#+BEGIN_SRC bash
# Development installation
pip install -e .

# Production installation (if using container)
# The CLI is already available as 'tg-wp-bridge' inside the container
#+END_SRC

** Available Commands

*** =webhook-info= - Display current Telegram webhook information

#+BEGIN_SRC bash
# Display webhook info in table format
tg-wp-bridge webhook-info

# Display webhook info in JSON format
tg-wp-bridge webhook-info --format json

# Use custom config file
tg-wp-bridge --config-file /path/to/.env webhook-info
#+END_SRC

*** =set-webhook= - Configure Telegram webhook

#+BEGIN_SRC bash
# Configure webhook (requires PUBLIC_BASE_URL and TELEGRAM_WEBHOOK_SECRET)
tg-wp-bridge set-webhook

# Dry run - show what would be configured without actually setting it
tg-wp-bridge set-webhook --dry-run

# Use custom config file
tg-wp-bridge --config-file /path/to/.env set-webhook
#+END_SRC

*** =wp-info= - Inspect WordPress API configuration

#+BEGIN_SRC bash
# Display currently configured WordPress endpoints and defaults
tg-wp-bridge wp-info

# Use custom config file
tg-wp-bridge --config-file /path/to/.env wp-info
#+END_SRC

*** =wp-check= - Verify WordPress reachability and credentials

#+BEGIN_SRC bash
# Ensure the configured WP base URL is reachable and credentials work
tg-wp-bridge wp-check

# Use custom config file
tg-wp-bridge --config-file /path/to/.env wp-check
#+END_SRC

*** =status= - Display bridge configuration and webhook status

#+BEGIN_SRC bash
# Show current configuration and webhook status
tg-wp-bridge status

# Use custom config file
tg-wp-bridge --config-file /path/to/.env status

# Enable debug logging
tg-wp-bridge --debug status
#+END_SRC

*** =startup-check= - Production startup routine

Runs all diagnostic checks, configures the webhook if missing (unless you pass
=--no-auto-fix-webhook=), and prints a pass/fail summary. Recommended to run at
container boot or health probes.

#+BEGIN_SRC bash
# Run full diagnostics and auto-fix missing webhook
tg-wp-bridge startup-check

# Skip auto-fixing the webhook (diagnostic only)
tg-wp-bridge startup-check --no-auto-fix-webhook
#+END_SRC

** Using CLI with Docker

The CLI commands can be executed against a running Docker container:

#+BEGIN_SRC bash
# Display webhook info
docker compose exec tg-wp-bridge tg-wp-bridge webhook-info

# Configure webhook
docker compose exec tg-wp-bridge tg-wp-bridge set-webhook

# Show status
docker compose exec tg-wp-bridge tg-wp-bridge status

# Dry run webhook setup
docker compose exec tg-wp-bridge tg-wp-bridge set-webhook --dry-run
#+END_SRC

** CLI Logging

The CLI provides comprehensive logging:

- INFO: Shows the operations being performed
- DEBUG: Detailed information (enable with =--debug= flag)
- Security-sensitive values (tokens, passwords) are masked in logs

Example with debug logging:

#+BEGIN_SRC bash
tg-wp-bridge --debug set-webhook
#+END_SRC

This will log the calculated webhook URL, API calls, and responses while keeping sensitive information secure.

** Typical Setup Workflow

1. Configure environment variables or =.env= file
2. Verify configuration:

#+BEGIN_SRC bash
tg-wp-bridge status
#+END_SRC

3. Test webhook configuration (dry run):

#+BEGIN_SRC bash
tg-wp-bridge set-webhook --dry-run
#+END_SRC

4. Configure webhook:

#+BEGIN_SRC bash
tg-wp-bridge set-webhook
#+END_SRC

5. Verify webhook is set:

#+BEGIN_SRC bash
tg-wp-bridge webhook-info
#+END_SRC

All commands can be run without the webserver running, making initial setup straightforward.

* Telegram Webhook Setup (Alternative Method)

Once the bridge is reachable over HTTPS and configured:

1. Start the bridge (Docker or locally).
2. Call the internal helper endpoint:

#+BEGIN_SRC bash
curl -X POST http://localhost:8000/telegram/set_webhook
#+END_SRC

3. Inspect webhook status:

#+BEGIN_SRC bash
curl http://localhost:8000/telegram/webhook_info
#+END_SRC

Telegram will then POST updates to:

#+BEGIN_SRC text
PUBLIC_BASE_URL/webhook/TELEGRAM_WEBHOOK_SECRET
#+END_SRC

* Tests

Pytest is used with some small unit tests:

#+BEGIN_SRC bash
uv run test
# or
uv run pytest --with pytest --with pytest-asyncio --with pydantic --with pydantic-settings --with fastapi --with httpx
#+END_SRC

Currently there are:
- =tests/test_message_parser.py= – channel message parsing & photo selection
- =tests/test_config.py= – sanity checks on settings loading

You can extend this with integration tests that hit a local WordPress instance
from the compose stack.

* Code Quality

The project includes several code quality tools that can be run via the hatch scripts:

#+BEGIN_SRC bash
# Run the type checker
uv run typecheck

# Run the linter
uv run lint

# Format the code
uv run format

# Run tests with coverage
uv run cov
#+END_SRC

These tools help maintain code quality:
- MyPy: static type checking
- Ruff: fast Python linter and formatter
- Black: code formatting (if needed)

* Security / Caveats

- Protect the =/telegram/set_webhook= and =/telegram/webhook_info= endpoints
  (e.g. via reverse proxy auth or IP allowlisting)
- Secrets should be managed by your orchestrator (Docker secrets, Kubernetes
  secrets, etc.), not committed to git.
- This bridge assumes simple channel posts; if you need albums, documents,
  or more complex formatting, extend =handle_telegram_update= accordingly.

* Extending

Ideas:

- support more stuff
- white | blacklisting
